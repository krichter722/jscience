<body>
<p> Provides strongly typed quantities to enforce compile-time check of 
    parameters consistency and avoid interface errors.</p>

<p> Let's take the following example:[code]
        class Person {
            void setWeight(double weight);
        }[/code]
    Should the weight be in pound, kilogram ??<br>
    With quantities there is no room for error:[code]
        class Person {
            void setWeight(Quantity<Mass> weight);
        }[/code]
    Not only the interface is cleaner (the weight has to be of mass type); 
    but also there is no confusion on the measurement unit:[code]
        double weightInKg = weight.doubleValue(SI.KILOGRAM);
        double weightInLb = weight.doubleValue(NonSI.POUND);[/code]
    Quantities work hand-in-hand with units (also parameterized).
    For example, the following would result in compile-time error:[code]
        double weightInGal = weight.doubleValue(NonSI.GALLON); // Compile error, Unit<Mass> required.
        [/code]</p>

<p> This package provides only one basic quantity implementation ({@link javax.measure.quantities.Scalar Scalar})
    from which limitless simple immutable quantities objects can be created. Users may define more advanced quantity implementations
    or simply use quantities interfaces to provide strong-typing to their own classes through parameterization.
    For example:[code]
         // Concrete quantity implementation embedding measurement error. 
         public class Measure<Q extends Quantity> implements Quantity<Q> { 
              public Measure(double value, double error, Unit<Q> unit) { ... }
              public double doubleValue(Unit<Q> unit) { ... } // Implements Quantity interface.
              public long longValue(Unit<Q> unit) { ... }   // Implements Quantity interface.
              ...
         } 
         Measure<Volume> v = new Measure<Volume>(20, 0.1, LITER); // (20 ± 0.1) L
         Measure<Frequency> f = new Measure<Frequency>(12.5, 0.05, GIGA(HERTZ)); // (12.5 ± 0.05) GHz

         // Parameterized complex number.
         public class Complex<Q extends Quantity>  { 
             public Complex(double real, double imaginary, Unit<Q> unit) { ... }
             ...
         }
         Complex<ElectricCurrent> i = new Complex(2, -3, MICRO(AMPERE)); // (2 - 3i) µA
         Complex<ElectricPotential> v = new Complex(12.3, 5.2, VOLT); // // (12.3 + 5.2i) V
         
         // Parameterized vector.
         public class Vector<Q extends Quantity>  { 
             public Vector(Unit<Q> unit, double... elements) { ... }
             ...
         }
         Vector<Velocity> v1 = new Vector<Velocity>(KILO(METER_PER_SECOND), 1.2, 3.5, -6.5);
         Vector<Angle> v2 = new Vector<Angle>(DEGREE_ANGLE, 34.5, 12.3);
    [/code]</p>
</body>